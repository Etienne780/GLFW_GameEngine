#pragma once
#include <queue>


namespace EngineCore {

	enum class IDOrder {
		// IDs are assigned in no strict order:
		// - IDFallback is on by default
		// - If available, IDs are taken from the free ID pool (m_freeIDs).
		// - Otherwise, new IDs are generated by incrementing m_idCounter.
		// This mode does not enforce ascending or descending ordering.
		RANDOME = 0,

		// IDs are assigned in ascending order:
		// - IDs are generated sequentially starting from 0 (or the Reset start value).
		// - Once the uint limit is reached, m_idFallback is set to true and
		//   IsIDFallback() will return true, indicating that no further ascending IDs
		//   can be generated.
		ASCENDING,

		// IDs are assigned in descending order:
		// - IDs are generated sequentially in decreasing order starting from UINT_MAX
		//   (or the Reset start value).
		// - Once the lower limit (0) is reached, m_idFallback is set to true and
		//   IsIDFallback() will return true, indicating that no further descending IDs
		//   can be generated.
		DESCENDING
	};

	class IDManager {
	public:
		IDManager(IDOrder order = IDOrder::RANDOME);
		~IDManager() = default;

		bool IsIDFallback();

		/*
		* @brief returns a uniqe int id and ENGINE_INVALID_ID if no free id was found
		*/
		unsigned int GetNewUniqueIdentifier() const;

		/*
		* @brief Frees an ID so it can be reused later.
		*
		* - The given ID is pushed into the free ID pool (m_freeIDs).
		* - On the next call to GetNewUniqueIdentifier(), the manager will prefer
		*   returning IDs from this pool (depending on the current IDOrder mode).
		* - Use this when an object is destroyed or no longer needs its ID.
		*/
		void FreeUniqueIdentifier(unsigned int id);

		/*
		* @brief resets the ID manager
		* @param sets the start value of the next free id
		*/
		void Reset(unsigned int startValue = 0);

		/*
		* @brief Sets the order in which new IDs are returned. Calls Reset on this Element. Default is IDOrder::RANDOME.
		*
		* - IDOrder::RANDOME:
		*	IDFallback is on by default
		*   IDs are returned without a strict sequence. The manager first tries to reuse
		*   IDs from the free ID pool (m_freeIDs). If none are available, m_idCounter
		*   is incremented to generate a new ID.
		*
		* - IDOrder::ASCENDING:
		*   IDs are returned in ascending order, starting at 0 (or the Reset start value).
		*   When the maximum uint value is reached, m_idFallback is set to true and
		*   IsIDFallback() will return true.
		*
		* - IDOrder::DESCENDING:
		*   IDs are returned in descending order, starting at UINT_MAX (or the Reset start value).
		*   When 0 is reached, m_idFallback is set to true and IsIDFallback() will return true.
		*/
		void SetIDOrder(IDOrder value);

	private:
		mutable unsigned int m_idCounter = 0;
		mutable bool m_idFallback = false;// gets set to true when the id limit(Integer.Max) is reached.
		mutable std::queue<unsigned int> m_freeIDs;
		IDOrder m_order = IDOrder::RANDOME;

		unsigned int GetNewUniqueIdentifierFallback() const;

		unsigned int GetNewUniqueIdentifierRandom() const;
		unsigned int GetNewUniqueIdentifierAscending() const;
		unsigned int GetNewUniqueIdentifierDescending() const;
	};

}